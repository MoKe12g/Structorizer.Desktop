#!/usr/bin/ksh
# Generated by Structorizer 3.30-06 
#  
# Copyright (C) 2019-10-02 Kay Gürtzig 
# License: GPLv3-link 
# GNU General Public License (V 3) 
# https://www.gnu.org/licenses/gpl.html 
# http://www.gnu.de/documents/gpl.de.html 
#  

# Implements the well-known BubbleSort algorithm. 
# Compares neigbouring elements and swaps them in case of an inversion. 
# Repeats this while inversions have been found. After every 
# loop passage at least one element (the largest one out of the 
# processed subrange) finds its final place at the end of the 
# subrange. 
function bubbleSort {
 typeset -n values=$1
# TODO: Check and revise the syntax of all expressions! 

 typeset ende=$(( length(${values}) - 2 ))

 # NOTE: Represents a REPEAT UNTIL loop, see conditional break at the end. 
 while :
 do
  # The index of the most recent swapping (-1 means no swapping done). 
  typeset posSwapped=$(( -1 ))

  for (( i=0; i<=${ende}; i++ ))
  do

   if [[ $(( ${values[${i}]} > ${values[${i}+1]} )) ]]
   then
    typeset temp=${values[${i}]}
    values[${i}]=$(( ${values[${i}+1]} ))
    values[${i}+1]=${temp}
    posSwapped=${i}
   fi

  done

  ende=$(( ${posSwapped} - 1 ))
  [[ ! (${posSwapped} < 0) ]] || break
 done

}

# Given a max-heap 'heap´ with element at index 'i´ possibly 
# violating the heap property wrt. its subtree upto and including 
# index range-1, restores heap property in the subtree at index i 
# again. 
function maxHeapify {
 typeset -n heap=$1
 typeset i=$2
 typeset range=$3
# TODO: Check and revise the syntax of all expressions! 

 # Indices of left and right child of node i 
 typeset right=$(( (${i}+1) * 2 ))
 typeset left=$(( ${right} - 1 ))
 # Index of the (local) maximum 
 typeset max=${i}

 if [[ ${left} < ${range} && ${heap[${left}]} > ${heap[${i}]} ]]
 then
  max=${left}
 fi

 if [[ ${right} < ${range} && ${heap[${right}]} > ${heap[${max}]} ]]
 then
  max=${right}
 fi

 if [[ ${max} != ${i} ]]
 then
  typeset temp=${heap[${i}]}
  heap[${i}]=${heap[${max}]}
  heap[${max}]=${temp}
  maxHeapify heap "${max}" "${range}"
 fi

}

# Partitions array values between indices start und stop-1 with 
# respect to the pivot element initially at index p into smaller 
# and greater elements. 
# Returns the new (and final) index of the pivot element (which 
# separates the sequence of smaller from the sequence of greater 
# elements). 
# This is not the most efficient algorithm (about half the swapping 
# might still be avoided) but it is pretty clear. 
function partition {
 typeset -n values=$1
 typeset start=$2
 typeset stop=$3
 typeset p=$4
# TODO: Check and revise the syntax of all expressions! 

 typeset pivot=${values[${p}]}
 # Tausche das Pivot-Element an den start 
 values[${p}]=${values[${start}]}
 values[${start}]=${pivot}
 p=${start}
 # Beginning and end of the remaining unknown range 
 start=$(( ${start} + 1 ))
 stop=$(( ${stop} - 1 ))

 # Still unseen elements? 
 while [[ ${stop} >= ${start} ]]
 do
  typeset seen=${values[${start}]}

  if [[ ${values[${start}]} <= ${pivot} ]]
  then
   # Swap pivot element with start element 
   values[${p}]=${seen}
   values[${start}]=${pivot}
   p=$(( ${p} + 1 ))
   start=$(( ${start} + 1 ))

  else
   # Put the found element to the end of the unknown area 
   values[${start}]=${values[${stop}]}
   values[${stop}]=${seen}
   stop=$(( ${stop} - 1 ))
  fi

 done

 result6c06397d=p
}

# Checks whether or not the passed-in array is (ascendingly) sorted. 
function testSorted {
 typeset numbers=$1
# TODO: Check and revise the syntax of all expressions! 

 typeset isSorted=1
 typeset i=0

 # As we compare with the following element, we must stop at the penultimate index 
 while (( $(( ${isSorted} && (${i} <= length(${numbers})-2) )) ))
 do

  # Is there an inversion? 
  if [[ $(( ${numbers[${i}]} > ${numbers[${i}+1]} )) ]]
  then
   isSorted=0

  else
   i=$(( ${i} + 1 ))
  fi

 done

 result52c06b75=isSorted
}

# Runs through the array heap and converts it to a max-heap 
# in a bottom-up manner, i.e. starts above the "leaf" level 
# (index >= length(heap) div 2) and goes then up towards 
# the root. 
function buildMaxHeap {
 typeset heap=$1
# TODO: Check and revise the syntax of all expressions! 

 typeset lgth=$( length "${heap}" )

 for (( k=$(( ${lgth} / 2 - 1 )); k>=0; k-- ))
 do
  maxHeapify "${heap}" "${k}" "${lgth}"
 done

}

# Recursively sorts a subrange of the given array 'values´.  
# start is the first index of the subsequence to be sorted, 
# stop is the index BEHIND the subsequence to be sorted. 
function quickSort {
 typeset values=$1
 typeset start=$2
 typeset stop=$3
# TODO: Check and revise the syntax of all expressions! 

 # At least 2 elements? (Less don't make sense.) 
 if [[ $(( ${stop} >= ${start} + 2 )) ]]
 then
  # Select a pivot element, be p its index. 
  # (here: randomly chosen element out of start ... stop-1) 
  typeset p=$(( random(${stop}-${start}) + ${start} ))
  # Partition the array into smaller and greater elements 
  # Get the resulting (and final) position of the pivot element 
  partition "${values}" "${start}" "${stop}" "${p}"
  p=${result6c06397d}
  # Sort subsequances separately and independently ... 
  # ========================================================== 
  # ================= START PARALLEL SECTION ================= 
  # ========================================================== 
  pids6a64ce6d=""
  (
   # Sort left (lower) array part 
   quickSort "${values}" "${start}" "${p}"
  ) &
  pids6a64ce6d="${pids6a64ce6d} $!"
  (
   # Sort right (higher) array part 
   quickSort "${values}" $(( ${p}+1 )) "${stop}"
  ) &
  pids6a64ce6d="${pids6a64ce6d} $!"
  wait ${pids6a64ce6d}
  # ========================================================== 
  # ================== END PARALLEL SECTION ================== 
  # ========================================================== 
 fi

}

# Sorts the array 'values´ of numbers according to he heap sort 
# algorithm 
function heapSort {
 typeset -n values=$1
# TODO: Check and revise the syntax of all expressions! 

 buildMaxHeap values
 typeset heapRange=$( length values )

 for (( k=$(( ${heapRange} - 1 )); k>=1; k-- ))
 do
  heapRange=$(( ${heapRange} - 1 ))
  # Swap the maximum value (root of the heap) to the heap end 
  typeset maximum=${values[0]}
  values[0]=${values[${heapRange}]}
  values[${heapRange}]=${maximum}
  maxHeapify values 0 "${heapRange}"
 done

}

# Creates three equal arrays of numbers and has them sorted with different sorting algorithms 
# to allow performance comparison via execution counting ("Collect Runtime Data" should 
# sensibly be switched on). 
# Requested input data are: Number of elements (size) and filing mode. 
# TODO: Check and revise the syntax of all expressions! 

# NOTE: Represents a REPEAT UNTIL loop, see conditional break at the end. 
while :
do
 read elementCount
 (( ! (${elementCount} >= 1) )) || break
done

# NOTE: Represents a REPEAT UNTIL loop, see conditional break at the end. 
while :
do
 echo -n "Filling: 1 = random, 2 = increasing, 3 = decreasing" ; read modus
 [[ ! (${modus} == 1 || ${modus} == 2 || ${modus} == 3) ]] || break
done

for (( i=0; i<=$(( ${elementCount}-1 )); i++ ))
do

 case ${modus} in

  1)
    values1[${i}]=$( random 10000 )
  ;;

  2)
    values1[${i}]=${i}
  ;;

  3)
    values1[${i}]=$(( -${i} ))
  ;;
 esac

done

# Copy the array for exact comparability 
for (( i=0; i<=$(( ${elementCount}-1 )); i++ ))
do
 values2[${i}]=${values1[${i}]}
 values3[${i}]=${values1[${i}]}
done

# ========================================================== 
# ================= START PARALLEL SECTION ================= 
# ========================================================== 
pids7feeee28=""
(
 bubbleSort values1
) &
pids7feeee28="${pids7feeee28} $!"
(
 quickSort values2 0 "${elementCount}"
) &
pids7feeee28="${pids7feeee28} $!"
(
 heapSort values3
) &
pids7feeee28="${pids7feeee28} $!"
wait ${pids7feeee28}
# ========================================================== 
# ================== END PARALLEL SECTION ================== 
# ========================================================== 
testSorted values1
ok1=${result52c06b75}
testSorted values2
ok2=${result52c06b75}
testSorted values3
ok3=${result52c06b75}

if [[ ! ${ok1} || ! ${ok2} || ! ${ok3} ]]
then

 for (( i=0; i<=$(( ${elementCount}-1 )); i++ ))
 do

  if [[ ${values1[${i}]} != ${values2[${i}]} || ${values1[${i}]} != ${values3[${i}]} ]]
  then
   echo "Difference at [" ${i} "]: " ${values1[${i}]} " <-> " ${values2[${i}]} " <-> " ${values3[${i}]}
  fi

 done

fi

# NOTE: Represents a REPEAT UNTIL loop, see conditional break at the end. 
while :
do
 echo -n "Show arrays (yes/no)?" ; read show
 [[ ! (${show} == "yes" || ${show} == "no") ]] || break
done

if [[ ${show} == "yes" ]]
then

 for (( i=0; i<=$(( ${elementCount} - 1 )); i++ ))
 do
  echo "[" ${i} "]:\t" ${values1[${i}]} "\t" ${values2[${i}]} "\t" ${values3[${i}]}
 done

fi

